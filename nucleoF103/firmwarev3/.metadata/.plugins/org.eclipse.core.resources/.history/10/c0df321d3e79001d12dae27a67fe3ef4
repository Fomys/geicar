/*
 * control.c
 *
 *  Created on: 12 nov. 2021
 *      Author: Carole Meyer
 */


/* Includes ------------------------------------------------------------------*/

#include "control.h"


/* Private define ------------------------------------------------------------*/
//left wheel PID corrector parameters
#define Kp_l 1.0;
#define Ki_l 0.01;
#define Kd_l 0.0;
//right wheel PID corrector parameters
#define Kp_r 1.0;
#define Ki_r 0.01;
#define Kd_r 0.0;
//steering PID corrector parameters
#define Kp_s 1.0;
#define Ki_s 1.0;
#define Kd_s 1.0;


/* Private variables ---------------------------------------------------------*/
float previousSpeedErrorRight;
float previousSpeedErrorLeft;
float previousAngleError;
float sumIntegralLeft = 0;
float sumIntegralRight = 0;
float sumIntegralAngle = 0;

/* Programs ------------------------------------------------------------------*/

/**
*	Update motor speeds
**/
void car_control(int left_rear_speed, int right_rear_speed, int steering_speed, int current_left, int current_right){

	int speed_left;
	int speed_right;
	int angle;

	if (left_rear_speed == DISABLED && right_rear_speed == DISABLED && steering_speed == DISABLED){

		wheels_set_speed(GPIO_PIN_RESET, GPIO_PIN_RESET, STOP, STOP);
		steering_set_speed(GPIO_PIN_RESET, STOP);

	} else {

		//Propulsion
		speed_left = PI_speed_left(left_rear_speed, current_left);
		speed_right = PI_speed_right(right_rear_speed, current_right);
		wheels_set_speed(GPIO_PIN_SET, GPIO_PIN_SET, speed_right, speed_left);

		//Steering
		steering_set_speed(GPIO_PIN_SET, steering_speed);
	}
}

/*
 * PI Controller Compute output PWM
 */
int PI_speed_left(int left_rear_speed, int currentLeftRearSpeed)
{
	float speedErrorLeft;

	float deltaErrorLeft;

	float leftPwmCmd;

	//Computation of the error for Kp
	speedErrorLeft = left_rear_speed - currentLeftRearSpeed;

	//Computation of the error for Ki
	sumIntegralLeft += speedErrorLeft;

	//Computation of the error for Kd
	deltaErrorLeft = speedErrorLeft - previousSpeedErrorLeft;
	previousSpeedErrorLeft = speedErrorLeft;

	//Computation of the command that must be sent to the motors
	leftPwmCmd = speedErrorLeft * Kp_l + sumIntegralLeft * Ki_l + deltaErrorLeft * Kd_l;

	if ( left_rear_speed >= 0)
	{
		if (leftPwmCmd < 0)
			leftPwmCmd = 0;
		else if (leftPwmCmd > 50)
			leftPwmCmd = 50;
		//Set the offset, because cmd = [0 : 50] goes backwards
		// And cmd = [50 : 100] goes forwards
		leftPwmCmd += 50;
	}
	else if (left_rear_speed < 0)
	{
		if (leftPwmCmd > 0)
			leftPwmCmd = 0;
		else if (leftPwmCmd < -50)
			leftPwmCmd = -50;

		//Set the offset, because cmd = [0 : 50] goes backwards
		// And cmd = [50 : 100] goes forwards
		leftPwmCmd += 50;
	}
	return leftPwmCmd;

}

int PI_speed_right(int right_rear_speed, int currentRightRearSpeed)
{
	float speedErrorRight;

	float deltaErrorRight ;

	float rightPwmCmd;

	//Computation of the error for Kp
	speedErrorRight = right_rear_speed - currentRightRearSpeed;

	//Computation of the error for Ki
	sumIntegralRight += speedErrorRight;

	//Computation of the error for Kd
	deltaErrorRight = speedErrorRight - previousSpeedErrorRight;
	previousSpeedErrorRight = speedErrorRight;

	//Computation of the command that must be sent to the motors
	rightPwmCmd = speedErrorRight * Kp_r + sumIntegralRight * Ki_r + deltaErrorRight * Kd_r;

	if ( right_rear_speed >= 0)
	{
		if (rightPwmCmd < 0)
			rightPwmCmd = 0;
		else if (rightPwmCmd > 50)
			rightPwmCmd = 50;
		//Set the offset, because cmd = [0 : 50] goes backwards
		// And cmd = [50 : 100] goes forwards
		rightPwmCmd += 50;
	}
	else if (right_rear_speed < 0)
	{
		if (rightPwmCmd > 0)
			rightPwmCmd = 0;
		else if (rightPwmCmd < -50)
			rightPwmCmd = -50;
		//Set the offset, because cmd = [0 : 50] goes backwards
		// And cmd = [50 : 100] goes forwards
		rightPwmCmd += 50;
	}
	return rightPwmCmd;
}

int PI_angle(int steering_angle)
{
	float angleError;

	float deltaError ;

	float anglePwmCmd;

	//Computation of the error for Kp
	angleError = steering_angle - steering_get_angle();

	//Computation of the error for Ki
	sumIntegralRight += angleError;

	//Computation of the error for Kd
	deltaError = angleError - previousAngleError;
	previousAngleError = angleError;

	//Computation of the command that must be sent to the motors
	anglePwmCmd = angleError * Kp_r + sumIntegralAngle * Ki_r + deltaError * Kd_r;

	if (anglePwmCmd < 0)
			anglePwmCmd = 0;
	else if (anglePwmCmd > 100)
		anglePwmCmd = 100;
		//Set the offset, because cmd = [0 : 50] goes backwards
		// And cmd = [50 : 100] goes forwards
	return anglePwmCmd;


}
